
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>1945 SKY WARRIOR</title>
    <style>
        body { margin: 0; background: #222; overflow: hidden; touch-action: none; font-family: 'Courier New', monospace; }
        #game-container { position: relative; width: 100%; height: 100vh; display: flex; justify-content: center; background: #111; }
        canvas { display: block; max-width: 600px; width: 100%; height: 100%; background: #004477; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; max-width: 600px; }
        .hud-text { position: absolute; color: #fff; font-weight: bold; text-shadow: 2px 2px 0 #000; font-size: 20px; }
        #score-display { top: 20px; left: 20px; }
        #hp-display { top: 20px; right: 20px; }
        
        #screen-overlay { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            background: rgba(0,0,0,0.7); display: flex; flex-direction: column; 
            align-items: center; justify-content: center; pointer-events: auto;
            backdrop-filter: blur(4px);
            z-index: 10;
        }
        h1 { color: #ffcc00; font-size: 40px; margin-bottom: 10px; text-shadow: 4px 4px 0 #b35900; text-align: center; line-height: 1; }
        p { color: #eee; font-size: 16px; text-align: center; line-height: 1.5; margin-bottom: 30px; }
        button {
            background: #d93636; border: 3px solid #fff; color: white;
            padding: 15px 40px; font-size: 24px; font-weight: bold; font-family: inherit;
            cursor: pointer; text-transform: uppercase;
            box-shadow: 0 6px 0 #8b2323; transition: transform 0.1s;
        }
        button:active { transform: translateY(4px); box-shadow: 0 2px 0 #8b2323; }
        .hidden { display: none !important; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="canvas"></canvas>
    <div id="ui-layer">
        <div id="score-display" class="hud-text">SCORE: 0</div>
        <div id="hp-display" class="hud-text">HP: 100%</div>
        
        <div id="screen-overlay">
            <h1>SKY WARRIOR<br>1945</h1>
            <p>
                DESKTOP: WASD / ARROWS to Move, SPACE to Shoot<br>
                MOBILE: Drag to Move, Auto-Shoot
            </p>
            <button id="start-btn">SCRAMBLE</button>
        </div>
    </div>
</div>

<script>
    // Game Setup
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score-display');
    const hpEl = document.getElementById('hp-display');
    const overlay = document.getElementById('screen-overlay');
    const startBtn = document.getElementById('start-btn');
    const title = overlay.querySelector('h1');
    const subtitle = overlay.querySelector('p');

    let isPaused = false; // External pause state (from app)
    let gameRunning = false;
    let score = 0;
    let frames = 0;
    
    // Config
    const PLAYER_SPEED = 6;
    const BULLET_SPEED = 12;
    const ENEMY_SPEED_BASE = 3;

    // State
    const input = { left: false, right: false, up: false, down: false, fire: false };
    
    const player = {
        x: 0, y: 0, w: 40, h: 40, hp: 100, dead: false,
        img: null // Could use sprite, will draw vector
    };
    
    let bullets = [];
    let enemies = [];
    let particles = [];
    let clouds = [];

    // --- PAUSE LISTENER FOR APP ---
    window.addEventListener('message', (e) => {
        if (e.data && e.data.type === 'PAUSE_GAME') {
            isPaused = e.data.payload;
        }
    });

    // --- INPUTS ---
    window.addEventListener('keydown', e => {
        if(e.code === 'ArrowLeft' || e.code === 'KeyA') input.left = true;
        if(e.code === 'ArrowRight' || e.code === 'KeyD') input.right = true;
        if(e.code === 'ArrowUp' || e.code === 'KeyW') input.up = true;
        if(e.code === 'ArrowDown' || e.code === 'KeyS') input.down = true;
        if(e.code === 'Space') input.fire = true;
    });
    
    window.addEventListener('keyup', e => {
        if(e.code === 'ArrowLeft' || e.code === 'KeyA') input.left = false;
        if(e.code === 'ArrowRight' || e.code === 'KeyD') input.right = false;
        if(e.code === 'ArrowUp' || e.code === 'KeyW') input.up = false;
        if(e.code === 'ArrowDown' || e.code === 'KeyS') input.down = false;
        if(e.code === 'Space') input.fire = false;
    });

    // Touch
    let touchId = null;
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        input.fire = true; // Auto fire on mobile
        const t = e.changedTouches[0];
        touchId = t.identifier;
        updateTouchPos(t);
    }, {passive: false});
    
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        for(let i=0; i<e.changedTouches.length; i++) {
            if(e.changedTouches[i].identifier === touchId) {
                updateTouchPos(e.changedTouches[i]);
            }
        }
    }, {passive: false});
    
    canvas.addEventListener('touchend', e => {
        e.preventDefault();
        input.fire = false;
        touchId = null;
    });

    function updateTouchPos(t) {
        const rect = canvas.getBoundingClientRect();
        // Move player directly to finger with some offset/lerp or direct set
        // Direct set is responsive
        let tx = (t.clientX - rect.left) * (canvas.width / rect.width);
        let ty = (t.clientY - rect.top) * (canvas.height / rect.height);
        
        // Lerp towards touch for smoother feel
        player.x = tx;
        player.y = ty - 50; // Offset so finger doesn't cover plane
    }

    // --- RESIZE ---
    function resize() {
        const container = document.getElementById('game-container');
        if (container) {
            canvas.width = container.clientWidth > 600 ? 600 : container.clientWidth;
            canvas.height = container.clientHeight;
            
            // Reset player pos if out of bounds (initially)
            if(!gameRunning) {
                player.x = canvas.width / 2;
                player.y = canvas.height - 100;
            }
        }
    }
    window.addEventListener('resize', resize);
    resize();

    // --- DRAWING FUNCTIONS (Vector Arts) ---
    function drawPlayerPlane(ctx, x, y, w, h) {
        ctx.save();
        ctx.translate(x, y);
        
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.moveTo(0, -h*0.5 + 10);
        ctx.lineTo(w*0.8, h*0.4 + 10);
        ctx.lineTo(0, h*0.3 + 10);
        ctx.lineTo(-w*0.8, h*0.4 + 10);
        ctx.fill();

        // Main Body
        ctx.fillStyle = '#6d8c6b'; // Army Green
        ctx.beginPath();
        ctx.moveTo(0, -h*0.5);
        ctx.quadraticCurveTo(w*0.2, -h*0.2, w*0.1, h*0.5);
        ctx.lineTo(-w*0.1, h*0.5);
        ctx.quadraticCurveTo(-w*0.2, -h*0.2, 0, -h*0.5);
        ctx.fill();
        
        // Wings
        ctx.fillStyle = '#556b53';
        ctx.beginPath();
        ctx.moveTo(0, -h*0.2);
        ctx.lineTo(w*0.6, h*0.1);
        ctx.lineTo(w*0.6, h*0.3);
        ctx.lineTo(0, h*0.1);
        ctx.lineTo(-w*0.6, h*0.3);
        ctx.lineTo(-w*0.6, h*0.1);
        ctx.fill();
        
        // Cockpit
        ctx.fillStyle = '#aaddff';
        ctx.beginPath();
        ctx.ellipse(0, -h*0.1, w*0.08, h*0.15, 0, 0, Math.PI*2);
        ctx.fill();

        // Propeller (simple blur)
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.beginPath();
        ctx.arc(0, -h*0.55, w*0.4, 0, Math.PI*2);
        ctx.fill();
        
        ctx.restore();
    }

    function drawEnemyPlane(ctx, x, y, w, h, type) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(Math.PI); // Facing down
        
        // Color based on type
        const baseColor = type === 2 ? '#8b2323' : '#444'; // Red bomber or Grey fighter
        
        // Shadow
        ctx.fillStyle = 'rgba(0,0,0,0.3)';
        ctx.beginPath();
        ctx.moveTo(0, -h*0.5+5);
        ctx.lineTo(w, h*0.2+5);
        ctx.lineTo(0, h*0.5+5);
        ctx.lineTo(-w, h*0.2+5);
        ctx.fill();

        // Body
        ctx.fillStyle = baseColor;
        ctx.beginPath();
        ctx.moveTo(0, -h*0.5);
        ctx.lineTo(w*0.5, h*0.2);
        ctx.lineTo(0, h*0.5);
        ctx.lineTo(-w*0.5, h*0.2);
        ctx.fill();
        
        // Emblem
        ctx.fillStyle = '#d93636';
        ctx.beginPath();
        ctx.arc(0, 0, w*0.15, 0, Math.PI*2);
        ctx.fill();

        ctx.restore();
    }
    
    // --- GAME LOGIC ---
    function spawnCloud() {
        clouds.push({
            x: Math.random() * canvas.width,
            y: -100,
            size: 30 + Math.random() * 50,
            speed: 1 + Math.random() * 2
        });
    }

    function spawnEnemy() {
        const type = Math.random() > 0.8 ? 2 : 1; // 2 = big, 1 = small
        const size = type === 2 ? 60 : 35;
        const hp = type === 2 ? 5 : 1;
        enemies.push({
            x: Math.random() * (canvas.width - size * 2) + size,
            y: -50,
            w: size,
            h: size,
            type: type,
            hp: hp,
            vx: (Math.random() - 0.5) * 1, // Slight drift
            vy: ENEMY_SPEED_BASE * (type === 2 ? 0.7 : 1.0)
        });
    }

    function createExplosion(x, y, count) {
        for(let i=0; i<count; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 10,
                vy: (Math.random() - 0.5) * 10,
                life: 1.0,
                color: Math.random() > 0.5 ? '#ffaa00' : '#ffff00'
            });
        }
    }

    function start() {
        score = 0;
        player.hp = 100;
        player.dead = false;
        player.x = canvas.width / 2;
        player.y = canvas.height - 100;
        
        bullets = [];
        enemies = [];
        particles = [];
        clouds = [];
        
        scoreEl.innerText = "SCORE: 0";
        hpEl.innerText = "HP: 100%";
        hpEl.style.color = '#fff';
        
        overlay.classList.add('hidden');
        gameRunning = true;
        animate();
    }

    function gameOver() {
        gameRunning = false;
        overlay.classList.remove('hidden');
        title.innerText = "MISSION FAILED";
        subtitle.innerHTML = `FINAL SCORE: <span style="color:#ffcc00;font-size:24px">${score}</span>`;
        startBtn.innerText = "RETRY";
    }

    // --- LOOP ---
    function animate() {
        if(!gameRunning) return;
        requestAnimationFrame(animate);
        
        if(isPaused) return;

        frames++;
        
        // 1. Clear & Background
        ctx.fillStyle = '#004477'; // Deep ocean
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Ocean pattern (lines)
        ctx.fillStyle = '#005588';
        const offset = (frames * 2) % 50;
        for(let y = offset - 50; y < canvas.height; y += 50) {
            ctx.fillRect(0, y, canvas.width, 2);
        }

        // Clouds
        if(Math.random() < 0.02) spawnCloud();
        ctx.fillStyle = 'rgba(255,255,255,0.3)';
        for(let i = clouds.length - 1; i >= 0; i--) {
            let c = clouds[i];
            c.y += c.speed;
            
            // Draw cloud (circles)
            ctx.beginPath();
            ctx.arc(c.x, c.y, c.size, 0, Math.PI*2);
            ctx.arc(c.x + c.size*0.5, c.y + c.size*0.2, c.size*0.7, 0, Math.PI*2);
            ctx.fill();
            
            if(c.y > canvas.height + 100) clouds.splice(i, 1);
        }

        // 2. Player
        if(!player.dead) {
            // Movement
            let dx = 0; let dy = 0;
            if(input.left) dx -= PLAYER_SPEED;
            if(input.right) dx += PLAYER_SPEED;
            if(input.up) dy -= PLAYER_SPEED;
            if(input.down) dy += PLAYER_SPEED;
            
            player.x += dx;
            player.y += dy;
            
            // Clamp
            if(player.x < 20) player.x = 20;
            if(player.x > canvas.width - 20) player.x = canvas.width - 20;
            if(player.y < 20) player.y = 20;
            if(player.y > canvas.height - 20) player.y = canvas.height - 20;

            // Draw
            drawPlayerPlane(ctx, player.x, player.y, player.w, player.h);

            // Fire
            if(input.fire && frames % 8 === 0) {
                bullets.push({ 
                    x: player.x, y: player.y - 20, 
                    vx: 0, vy: -BULLET_SPEED, 
                    owner: 'player' 
                });
            }
        }

        // 3. Enemies
        // Spawn
        if(frames % 40 === 0) spawnEnemy();
        
        for(let i = enemies.length - 1; i >= 0; i--) {
            let e = enemies[i];
            e.y += e.vy;
            e.x += e.vx;
            
            // Enemy shoot
            if(e.type === 2 && Math.random() < 0.02 && e.y > 0) {
                 bullets.push({ 
                    x: e.x, y: e.y + 20, 
                    vx: (Math.random()-0.5)*2, vy: BULLET_SPEED * 0.6, 
                    owner: 'enemy' 
                });
            }

            drawEnemyPlane(ctx, e.x, e.y, e.w, e.h, e.type);

            // Collision w Player
            if(!player.dead && Math.abs(e.x - player.x) < (e.w + player.w)/2 && Math.abs(e.y - player.y) < (e.h + player.h)/2) {
                createExplosion(player.x, player.y, 50);
                createExplosion(e.x, e.y, 20);
                player.hp -= 20; // Crash dmg
                e.hp = 0; // Enemy dies
                hpEl.innerText = `HP: ${player.hp}%`;
                if(player.hp <= 0) {
                    player.dead = true;
                    setTimeout(gameOver, 1000);
                }
            }
            
            if(e.y > canvas.height + 50 || e.hp <= 0) {
                if(e.hp <= 0) {
                    createExplosion(e.x, e.y, 15 * e.type);
                    score += 100 * e.type;
                    scoreEl.innerText = `SCORE: ${score}`;
                }
                enemies.splice(i, 1);
            }
        }

        // 4. Bullets
        ctx.fillStyle = '#ffcc00';
        for(let i = bullets.length - 1; i >= 0; i--) {
            let b = bullets[i];
            b.x += b.vx;
            b.y += b.vy;
            
            // Draw
            if(b.owner === 'player') {
                ctx.fillStyle = '#ffcc00';
                ctx.fillRect(b.x - 2, b.y - 8, 4, 12);
                
                // Hit check
                for(let j = enemies.length - 1; j >= 0; j--) {
                    let e = enemies[j];
                    if(Math.abs(b.x - e.x) < e.w/2 && Math.abs(b.y - e.y) < e.h/2) {
                        e.hp--;
                        b.dead = true;
                        createExplosion(b.x, b.y, 5);
                        break;
                    }
                }
            } else {
                ctx.fillStyle = '#ff4444';
                ctx.beginPath();
                ctx.arc(b.x, b.y, 5, 0, Math.PI*2);
                ctx.fill();
                
                // Hit player
                if(!player.dead && Math.abs(b.x - player.x) < player.w/3 && Math.abs(b.y - player.y) < player.h/2) {
                     player.hp -= 10;
                     hpEl.innerText = `HP: ${player.hp}%`;
                     if(player.hp < 30) hpEl.style.color = 'red';
                     createExplosion(player.x, player.y, 10);
                     b.dead = true;
                     if(player.hp <= 0) {
                        player.dead = true;
                        setTimeout(gameOver, 1000);
                     }
                }
            }

            if(b.y < -20 || b.y > canvas.height + 20 || b.dead) {
                bullets.splice(i, 1);
            }
        }

        // 5. Particles
        for(let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.05;
            
            ctx.fillStyle = p.color;
            ctx.globalAlpha = p.life;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 3 * p.life, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
            
            if(p.life <= 0) particles.splice(i, 1);
        }
    }

    startBtn.addEventListener('click', start);
</script>
</body>
</html>
